use uniffi::custom_newtype;

use crate::{
    errors::CloakedAiError, Edek, EncryptedBytes, FieldId, IronCoreMetadata, PlaintextBytes,
};
use std::{collections::HashMap, sync::Arc};

pub type PlaintextDocument = HashMap<FieldId, PlaintextBytes>;
#[derive(Debug)]
pub struct EdekWithKeyIdHeader(pub Vec<u8>);
custom_newtype!(EdekWithKeyIdHeader, Vec<u8>);
/// Document and EDEK (encrypted document encryption key) generated by `document_encrypt`/`documentEncrypt`.
/// Note that `document_encrypt_deterministic`/`documentEncryptDeterministic` doesn't use this type
/// as it prefixes an encryption header to the encrypted document map instead of using a separate EDEK.
#[derive(Debug, uniffi::Record)]
pub struct EncryptedDocument {
    /// Encrypted Document Encryption Key used when the document was encrypted
    pub edek: EdekWithKeyIdHeader,
    /// Map from field name to encrypted document bytes
    pub document: HashMap<FieldId, EncryptedBytes>,
}
// returned from decryption or created when trying to re-use an edek
#[derive(uniffi::Record)]
pub struct PlaintextDocumentWithEdek {
    edek: Edek,
    document: PlaintextDocument,
}

/// API for encrypting and decrypting documents using our standard encryption. This class of encryption is the most
/// broadly useful and secure. If you don't have a need to match on or preserve the distance properties of the
/// encrypted value, this is likely the API you should use. Our standard encryption is fully random (or probabilistic)
/// AES 256.
pub trait StandardDocumentOps {
    /// Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
    /// bytes, and the same metadata must be provided when decrypting the document.
    /// A DEK (document encryption key) will be generated and encrypted using a derived key, then each field of the
    /// document will be encrypted separately using a random IV and this single generated DEK.
    /// The result contains a map from field identifiers to encrypted bytes as well as the EDEK (encrypted document
    /// encryption key) used for encryption.
    /// The document is encrypted differently with each call, so the result is not suited for exact matches or indexing.
    /// For the same reason however the strongest protection of the document is provided by this method.
    /// To support these uses, see the `DeterministicFieldOps.encrypt` function.
    async fn encrypt(
        &self,
        plaintext_document: PlaintextDocument,
        metadata: &IronCoreMetadata,
    ) -> Result<EncryptedDocument, CloakedAiError>;
    /// Decrypt a document that was encrypted with the provided metadata. The document must have been encrypted with one
    /// of the `StandardDocumentOps.encrypt` functions. The result contains a map from field identifiers to decrypted
    /// bytes.
    async fn decrypt(
        &self,
        encrypted_document: EncryptedDocument,
        metadata: &IronCoreMetadata,
    ) -> Result<PlaintextDocument, CloakedAiError>;
    /// Generate a prefix that could used to search a data store for documents encrypted using an identifier (KMS
    /// config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
    /// a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
    /// `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
    /// avoid pitfalls when encoding across byte boundaries.
    fn get_searchable_edek_prefix(&self, id: u32) -> Vec<u8>;
}
