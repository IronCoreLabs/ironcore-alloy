# ironcore-alloy Kotlin Benchmarks

This directory contains a benchmark suite for the Kotlin version of ironcore-alloy.
To build and run the benchmark, just execute the following commands from the `kotlin` directory:

```
docker compose up -d
./gradlew bench
```

## Tenant Security Proxy

In order to run the benchmarks, ironcore-alloy needs to connect to a _Tenant Security Proxy (TSP)_.
This service is provided as a Docker container, so it is easy to run the proxy on any computer that has Docker
installed. IronCore Labs hosts the Docker container on a publicly accessible container registry, so you can pull
the image from there and run it locally.

In addition to the Docker containers, you need a configuration file that specifies how the TSP should communicate
with the IronCore Labs Configuration Broker and Data Control Platform, which work together to enable the end-to-end
encryption that keeps all of the tenant KMS configuration information secure. To simplify the process of running
these examples, we have created a demo vendor and tenants that you can use for the examples; all the necessary
configuration information is included in the [demo-tsp.conf](demo-tsp.conf) file in this directory.

**NOTE:** Normally, the file containing the configuration would be generated by the vendor and loaded into a
Kubernetes secret or similar mechanism for securely loading the configuration into the docker container. We
have included this configuration in the repository as a convenience. Also note that these accounts are all
created in IronCore's staging infrastructure.

Production TSPs will often be accompanied by one or more
[Tenant Security Logdriver](https://ironcorelabs.com/docs/saas-shield/tenant-security-logdriver/overview/) instances.
Because the purpose of this benchmark is to demonstrate the capabilities of ironcore-alloy Kotlin, we have chosen to not include
Logdriver in it. If you wish to modify the Docker Compose file to include Logdriver, be sure to consult its
[Deployment](https://ironcorelabs.com/docs/saas-shield/tenant-security-logdriver/deployment/) page to learn how to properly configure it
based on the resources you have available.

The following `docker compose` command will get a TSP running on your computer with the provided configuration:

```
docker compose up
```

This starts the TSP locally listening on port 32804. The benchmark expects to connect to the TSP at that address.

To connect with and use the TSP, you need to supply a couple more configuration values:
the first is the API key that the TSP uses to authenticate requests from ironcore-alloy,
and the second is the tenant ID to use.

The API key value is specified in the `demo-tsp.conf` file. You can just set the environment variable to the
same value:

`export API_KEY=0WUaXesNgbTAuLwn`

The benchmark can be run using a different cloud KMS by selecting a different tenant configured for our demo SaaS vendor.
There are six tenants defined; their IDs are the following:

- tenant-gcp
- tenant-aws
- tenant-azure
- tenant-gcp-l
- tenant-aws-l
- tenant-azure-l

The last three are similar to the first three, but they have _key leasing_ enabled.

By default, the benchmark will use the `tenant-gcp-l` tenant. If you would like to experiment with a different tenant, just do:

```bash
export TENANT_ID=<select tenant ID>
```

before running the benchmark.

## Interpreting Results

Since ironcore-alloy is a library that interacts with a back-end service (TSP), the benchmark results are not always straightforward to interpret. Most API calls in ironcore-alloy make a round-trip to the TSP, and the TSP also does some computation. If testing on a single machine, it is good to monitor the CPU/RAM usage of the TSP processes in addition to the Kotlin benchmark process to make sure you aren't resource constrained.

In general, operation latency is a function of latency to the TSP + latency to the tenant's KMS (if key-leasing is disabled).

The benchmark is using a single tenant, and (depending on your machine and benchmark config) can easily be executing a few thousand ops/sec. If you run the benchmark long enough you can overwhelm the TSP. In a real application, you would scale-out the TSP at this point. See [the TSP documentation](https://ironcorelabs.com/docs/saas-shield/tenant-security-proxy/deployment/) for more details.

## Other Languages

There are also benchmarks available in [Rust](https://github.com/IronCoreLabs/ironcore-alloy/tree/main/benches), [Java](https://github.com/IronCoreLabs/ironcore-alloy/tree/main/java/src/jmh/java/com/ironcorelabs/ironcore_alloy_java), and [Python](https://github.com/IronCoreLabs/ironcore-alloy/blob/main/python/ironcore-alloy/bench.py).

## Results

The following benchmarking run was done on November 4th, 2025 on a Macbook M2 Max against a locally-run TSP.

```text
Benchmark                                             Mode  Cnt     Score     Error  Units
SaasShieldBenchmark.batchEncrypt10DocsOf100B          avgt    5   595.544 ±  68.429  us/op
SaasShieldBenchmark.tspDecrypt100B                    avgt    5   208.218 ±  48.369  us/op
SaasShieldBenchmark.tspDecrypt10KB                    avgt    5   310.667 ±  33.731  us/op
SaasShieldBenchmark.tspDecrypt1B                      avgt    5   205.129 ±  59.999  us/op
SaasShieldBenchmark.tspDecrypt1MB                     avgt    5  9485.698 ± 212.514  us/op
SaasShieldBenchmark.tspEncrypt100B                    avgt    5   199.253 ±  60.525  us/op
SaasShieldBenchmark.tspEncrypt10KB                    avgt    5   313.622 ±  27.888  us/op
SaasShieldBenchmark.tspEncrypt1B                      avgt    5   197.546 ±  64.288  us/op
SaasShieldBenchmark.tspEncrypt1MB                     avgt    5  9692.248 ± 231.200  us/op
StandaloneBenchmark.standaloneRoundtripStandard100Kb  avgt    5  1969.400 ±  57.144  us/op
StandaloneBenchmark.standaloneRoundtripStandard10B    avgt    5   107.105 ±  48.190  us/op
StandaloneBenchmark.standaloneRoundtripStandard10Kb   avgt    5   298.298 ±  76.837  us/op
StandaloneBenchmark.standaloneVectorEncrypt384d       avgt    5    69.624 ±  27.796  us/op
```
